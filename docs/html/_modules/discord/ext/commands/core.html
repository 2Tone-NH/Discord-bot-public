


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xml:lang="" lang="" version="-//W3C//DTD XHTML 1.1//EN" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
  <title>discord.ext.commands.core &mdash; UNHM Programming Club Discord Bot Documentation 0.0.1 documentation</title>
  

  

  

    <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'/>
    <link rel="stylesheet" href="../../../../_static/css/pdj.css" type="text/css" />

  

  

  
        <link rel="index" title="Index"
              href="../../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../../search.html"/>
    <link rel="top" title="UNHM Programming Club Discord Bot Documentation 0.0.1 documentation" href="../../../../index.html"/>
        <link rel="up" title="Module code" href="../../../index.html"/>

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="cache-control" content="public" />
    <meta name="robots" content="follow, all" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Add jQuery library -->
    <script type="text/javascript" src="http://code.jquery.com/jquery-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

  </head>

  <body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="../../../../index.html" class="fa fa-home"> UNHM Programming Club Discord Bot Documentation </a>
        <div role="search">
	  <form id ="rtd-search-form" class="wy-form"
		action="../../../../search.html" method="get">
	    <input type="text" name="q" placeholder="Search docs" />
	    <input type="hidden" name="check_keywords" value="yes" />
	    <input type="hidden" name="area" value="default" />
	  </form>
	</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	
          
          
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../faces-cog.html">Faces Cog</a></li>
</ul>

          
        

      </div>
      &nbsp;
    </nav>
    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      <nav class="wy-nav-top" id="barra-mobile" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="#">Por√£o do Juca</a>
      </nav>

      <div class="wy-nav-content">
	<div class="fundo-claro">
	</div>
	<div class="fundo-escuro">
	</div>

        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
	    
	    <!-- <ul class="wy-breadcrumbs"> -->
	    <!--   <li><a href="#">Docs</a> &raquo;</li> -->

	    <!--   <li>Features</li> -->
	    <!--   <li class="wy-breadcrumbs-aside"> -->

	    <!-- 	<a href="_sources/index.txt" rel="nofollow"> View page source</a> -->

	    <!--   </li> -->
	    <!-- </ul> -->
	    <!-- <hr/> -->
	  </div>

          <div role="main" class="">

	    <div id="content" class="hfeed entry-container hentry">
  <h1>Source code for discord.ext.commands.core</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The MIT License (MIT)</span>

<span class="sd">Copyright (c) 2015-present Rapptz</span>

<span class="sd">Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="sd">copy of this software and associated documentation files (the &quot;Software&quot;),</span>
<span class="sd">to deal in the Software without restriction, including without limitation</span>
<span class="sd">the rights to use, copy, modify, merge, publish, distribute, sublicense,</span>
<span class="sd">and/or sell copies of the Software, and to permit persons to whom the</span>
<span class="sd">Software is furnished to do so, subject to the following conditions:</span>

<span class="sd">The above copyright notice and this permission notice shall be included in</span>
<span class="sd">all copies or substantial portions of the Software.</span>

<span class="sd">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="sd">OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="sd">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="sd">AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="sd">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span>
<span class="sd">FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</span>
<span class="sd">DEALINGS IN THE SOFTWARE.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="kn">import</span> <span class="nn">discord</span>

<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.cooldowns</span> <span class="kn">import</span> <span class="n">Cooldown</span><span class="p">,</span> <span class="n">BucketType</span><span class="p">,</span> <span class="n">CooldownMapping</span><span class="p">,</span> <span class="n">MaxConcurrency</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">converter</span> <span class="k">as</span> <span class="n">converters</span>
<span class="kn">from</span> <span class="nn">._types</span> <span class="kn">import</span> <span class="n">_BaseCommand</span>
<span class="kn">from</span> <span class="nn">.cog</span> <span class="kn">import</span> <span class="n">Cog</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s1">&#39;Command&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Group&#39;</span><span class="p">,</span>
    <span class="s1">&#39;GroupMixin&#39;</span><span class="p">,</span>
    <span class="s1">&#39;command&#39;</span><span class="p">,</span>
    <span class="s1">&#39;group&#39;</span><span class="p">,</span>
    <span class="s1">&#39;has_role&#39;</span><span class="p">,</span>
    <span class="s1">&#39;has_permissions&#39;</span><span class="p">,</span>
    <span class="s1">&#39;has_any_role&#39;</span><span class="p">,</span>
    <span class="s1">&#39;check&#39;</span><span class="p">,</span>
    <span class="s1">&#39;check_any&#39;</span><span class="p">,</span>
    <span class="s1">&#39;before_invoke&#39;</span><span class="p">,</span>
    <span class="s1">&#39;after_invoke&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bot_has_role&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bot_has_permissions&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bot_has_any_role&#39;</span><span class="p">,</span>
    <span class="s1">&#39;cooldown&#39;</span><span class="p">,</span>
    <span class="s1">&#39;max_concurrency&#39;</span><span class="p">,</span>
    <span class="s1">&#39;dm_only&#39;</span><span class="p">,</span>
    <span class="s1">&#39;guild_only&#39;</span><span class="p">,</span>
    <span class="s1">&#39;is_owner&#39;</span><span class="p">,</span>
    <span class="s1">&#39;is_nsfw&#39;</span><span class="p">,</span>
    <span class="s1">&#39;has_guild_permissions&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bot_has_guild_permissions&#39;</span>
<span class="p">)</span>

<span class="k">def</span> <span class="nf">wrap_callback</span><span class="p">(</span><span class="n">coro</span><span class="p">):</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">coro</span><span class="p">)</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="k">await</span> <span class="n">coro</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">CommandError</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CommandInvokeError</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">exc</span>
        <span class="k">return</span> <span class="n">ret</span>
    <span class="k">return</span> <span class="n">wrapped</span>

<span class="k">def</span> <span class="nf">hooked_wrapped_callback</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">coro</span><span class="p">):</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">coro</span><span class="p">)</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="k">await</span> <span class="n">coro</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">CommandError</span><span class="p">:</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">command_failed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">raise</span>
        <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">command_failed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">command_failed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">raise</span> <span class="n">CommandInvokeError</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">exc</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">command</span><span class="o">.</span><span class="n">_max_concurrency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">command</span><span class="o">.</span><span class="n">_max_concurrency</span><span class="o">.</span><span class="n">release</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>

            <span class="k">await</span> <span class="n">command</span><span class="o">.</span><span class="n">call_after_hooks</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>
    <span class="k">return</span> <span class="n">wrapped</span>

<span class="k">def</span> <span class="nf">_convert_to_bool</span><span class="p">(</span><span class="n">argument</span><span class="p">):</span>
    <span class="n">lowered</span> <span class="o">=</span> <span class="n">argument</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">lowered</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;yes&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;true&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;enable&#39;</span><span class="p">,</span> <span class="s1">&#39;on&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">lowered</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;no&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;false&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;disable&#39;</span><span class="p">,</span> <span class="s1">&#39;off&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">BadBoolArgument</span><span class="p">(</span><span class="n">lowered</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_CaseInsensitiveDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">casefold</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">casefold</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">casefold</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">casefold</span><span class="p">(),</span> <span class="n">default</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">casefold</span><span class="p">(),</span> <span class="n">default</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">casefold</span><span class="p">(),</span> <span class="n">v</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Command</span><span class="p">(</span><span class="n">_BaseCommand</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;A class that implements the protocol for a bot text command.</span>

<span class="sd">    These are not created manually, instead they are created via the</span>
<span class="sd">    decorator or functional interface.</span>

<span class="sd">    Attributes</span>
<span class="sd">    -----------</span>
<span class="sd">    name: :class:`str`</span>
<span class="sd">        The name of the command.</span>
<span class="sd">    callback: :ref:`coroutine &lt;coroutine&gt;`</span>
<span class="sd">        The coroutine that is executed when the command is called.</span>
<span class="sd">    help: :class:`str`</span>
<span class="sd">        The long help text for the command.</span>
<span class="sd">    brief: Optional[:class:`str`]</span>
<span class="sd">        The short help text for the command.</span>
<span class="sd">    usage: Optional[:class:`str`]</span>
<span class="sd">        A replacement for arguments in the default help text.</span>
<span class="sd">    aliases: Union[List[:class:`str`], Tuple[:class:`str`]]</span>
<span class="sd">        The list of aliases the command can be invoked under.</span>
<span class="sd">    enabled: :class:`bool`</span>
<span class="sd">        A boolean that indicates if the command is currently enabled.</span>
<span class="sd">        If the command is invoked while it is disabled, then</span>
<span class="sd">        :exc:`.DisabledCommand` is raised to the :func:`.on_command_error`</span>
<span class="sd">        event. Defaults to ``True``.</span>
<span class="sd">    parent: Optional[:class:`Command`]</span>
<span class="sd">        The parent command that this command belongs to. ``None`` if there</span>
<span class="sd">        isn&#39;t one.</span>
<span class="sd">    cog: Optional[:class:`Cog`]</span>
<span class="sd">        The cog that this command belongs to. ``None`` if there isn&#39;t one.</span>
<span class="sd">    checks: List[Callable[[:class:`.Context`], :class:`bool`]]</span>
<span class="sd">        A list of predicates that verifies if the command could be executed</span>
<span class="sd">        with the given :class:`.Context` as the sole parameter. If an exception</span>
<span class="sd">        is necessary to be thrown to signal failure, then one inherited from</span>
<span class="sd">        :exc:`.CommandError` should be used. Note that if the checks fail then</span>
<span class="sd">        :exc:`.CheckFailure` exception is raised to the :func:`.on_command_error`</span>
<span class="sd">        event.</span>
<span class="sd">    description: :class:`str`</span>
<span class="sd">        The message prefixed into the default help command.</span>
<span class="sd">    hidden: :class:`bool`</span>
<span class="sd">        If ``True``\, the default help command does not show this in the</span>
<span class="sd">        help output.</span>
<span class="sd">    rest_is_raw: :class:`bool`</span>
<span class="sd">        If ``False`` and a keyword-only argument is provided then the keyword</span>
<span class="sd">        only argument is stripped and handled as if it was a regular argument</span>
<span class="sd">        that handles :exc:`.MissingRequiredArgument` and default values in a</span>
<span class="sd">        regular matter rather than passing the rest completely raw. If ``True``</span>
<span class="sd">        then the keyword-only argument will pass in the rest of the arguments</span>
<span class="sd">        in a completely raw matter. Defaults to ``False``.</span>
<span class="sd">    invoked_subcommand: Optional[:class:`Command`]</span>
<span class="sd">        The subcommand that was invoked, if any.</span>
<span class="sd">    require_var_positional: :class:`bool`</span>
<span class="sd">        If ``True`` and a variadic positional argument is specified, requires</span>
<span class="sd">        the user to specify at least one argument. Defaults to ``False``.</span>

<span class="sd">        .. versionadded:: 1.5</span>

<span class="sd">    ignore_extra: :class:`bool`</span>
<span class="sd">        If ``True``\, ignores extraneous strings passed to a command if all its</span>
<span class="sd">        requirements are met (e.g. ``?foo a b c`` when only expecting ``a``</span>
<span class="sd">        and ``b``). Otherwise :func:`.on_command_error` and local error handlers</span>
<span class="sd">        are called with :exc:`.TooManyArguments`. Defaults to ``True``.</span>
<span class="sd">    cooldown_after_parsing: :class:`bool`</span>
<span class="sd">        If ``True``\, cooldown processing is done after argument parsing,</span>
<span class="sd">        which calls converters. If ``False`` then cooldown processing is done</span>
<span class="sd">        first and then the converters are called second. Defaults to ``False``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># if you&#39;re wondering why this is done, it&#39;s because we need to ensure</span>
        <span class="c1"># we have a complete original copy of **kwargs even for classes that</span>
        <span class="c1"># mess with it by popping before delegating to the subclass __init__.</span>
        <span class="c1"># In order to do this, we need to control the instance creation and</span>
        <span class="c1"># inject the original kwargs through __new__ rather than doing it</span>
        <span class="c1"># inside __init__.</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

        <span class="c1"># we do a shallow copy because it&#39;s probably the most common use case.</span>
        <span class="c1"># this could potentially break if someone modifies a list or something</span>
        <span class="c1"># while it&#39;s in movement, but for now this is the cheapest and</span>
        <span class="c1"># fastest way to do what we want.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__original_kwargs__</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">iscoroutinefunction</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Callback must be a coroutine.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Name of a command must be a string.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;enabled&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="n">help_doc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;help&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">help_doc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">help_doc</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">cleandoc</span><span class="p">(</span><span class="n">help_doc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">help_doc</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getdoc</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">help_doc</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
                <span class="n">help_doc</span> <span class="o">=</span> <span class="n">help_doc</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="n">help_doc</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">brief</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;brief&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">usage</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;usage&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rest_is_raw</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;rest_is_raw&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aliases</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;aliases&#39;</span><span class="p">,</span> <span class="p">[])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aliases</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Aliases of a command must be a list or a tuple of strings.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">cleandoc</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;description&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hidden</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;hidden&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">checks</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">__commands_checks__</span>
            <span class="n">checks</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">checks</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;checks&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">checks</span> <span class="o">=</span> <span class="n">checks</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">cooldown</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">__commands_cooldown__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">cooldown</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cooldown&#39;</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buckets</span> <span class="o">=</span> <span class="n">CooldownMapping</span><span class="p">(</span><span class="n">cooldown</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">max_concurrency</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">__commands_max_concurrency__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">max_concurrency</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_concurrency&#39;</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_max_concurrency</span> <span class="o">=</span> <span class="n">max_concurrency</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">require_var_positional</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;require_var_positional&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignore_extra</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ignore_extra&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cooldown_after_parsing</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cooldown_after_parsing&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cog</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># bandaid for the fact that sometimes parent can be the bot instance</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;parent&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">_BaseCommand</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">before_invoke</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">__before_invoke__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_before_invoke</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">before_invoke</span><span class="p">(</span><span class="n">before_invoke</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">after_invoke</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">__after_invoke__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_after_invoke</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">after_invoke</span><span class="p">(</span><span class="n">after_invoke</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callback</span>

    <span class="nd">@callback</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callback</span> <span class="o">=</span> <span class="n">function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">module</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="vm">__module__</span>

        <span class="n">signature</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">signature</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># PEP-563 allows postponing evaluation of annotations with a __future__</span>
        <span class="c1"># import. When postponed, Parameter.annotation will be a string and must</span>
        <span class="c1"># be replaced with the real value for the converters to work later on</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">annotation</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">annotation</span><span class="o">=</span><span class="nb">eval</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">annotation</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="vm">__globals__</span><span class="p">))</span>

            <span class="c1"># fail early for when someone passes an unparameterized Greedy type</span>
            <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">annotation</span> <span class="ow">is</span> <span class="n">converters</span><span class="o">.</span><span class="n">Greedy</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unparameterized Greedy[...] is disallowed in signature.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a check to the command.</span>

<span class="sd">        This is the non-decorator interface to :func:`.check`.</span>

<span class="sd">        .. versionadded:: 1.3</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        func</span>
<span class="sd">            The function that will be used as a check.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">checks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes a check from the command.</span>

<span class="sd">        This function is idempotent and will not raise an exception</span>
<span class="sd">        if the function is not in the command&#39;s checks.</span>

<span class="sd">        .. versionadded:: 1.3</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        func</span>
<span class="sd">            The function to remove from the checks.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">checks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates :class:`Command` instance with updated attribute.</span>

<span class="sd">        This works similarly to the :func:`.command` decorator in terms</span>
<span class="sd">        of parameters in that they are passed to the :class:`Command` or</span>
<span class="sd">        subclass constructors, sans the name and callback.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__original_kwargs__</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;|coro|</span>

<span class="sd">        Calls the internal callback that the command holds.</span>

<span class="sd">        .. note::</span>

<span class="sd">            This bypasses all mechanisms -- including checks, converters,</span>
<span class="sd">            invoke hooks, cooldowns, etc. You must take care to pass</span>
<span class="sd">            the proper arguments and types to this function.</span>

<span class="sd">        .. versionadded:: 1.3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cog</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ensure_assignment_on_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">other</span><span class="o">.</span><span class="n">_before_invoke</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_before_invoke</span>
        <span class="n">other</span><span class="o">.</span><span class="n">_after_invoke</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_after_invoke</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">checks</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">checks</span><span class="p">:</span>
            <span class="n">other</span><span class="o">.</span><span class="n">checks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checks</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buckets</span><span class="o">.</span><span class="n">valid</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">_buckets</span><span class="o">.</span><span class="n">valid</span><span class="p">:</span>
            <span class="n">other</span><span class="o">.</span><span class="n">_buckets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buckets</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_concurrency</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_max_concurrency</span><span class="p">:</span>
            <span class="n">other</span><span class="o">.</span><span class="n">_max_concurrency</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_concurrency</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">other</span><span class="o">.</span><span class="n">on_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_error</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a copy of this command.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        :class:`Command`</span>
<span class="sd">            A new instance of this command.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">__original_kwargs__</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_assignment_on_copy</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kw</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">kw</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__original_kwargs__</span><span class="p">)</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_assignment_on_copy</span><span class="p">(</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">dispatch_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">error</span><span class="p">):</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">command_failed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">cog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cog</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">coro</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_error</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">injected</span> <span class="o">=</span> <span class="n">wrap_callback</span><span class="p">(</span><span class="n">coro</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">injected</span><span class="p">(</span><span class="n">cog</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">injected</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">local</span> <span class="o">=</span> <span class="n">Cog</span><span class="o">.</span><span class="n">_get_overridden_method</span><span class="p">(</span><span class="n">cog</span><span class="o">.</span><span class="n">cog_command_error</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">local</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">wrapped</span> <span class="o">=</span> <span class="n">wrap_callback</span><span class="p">(</span><span class="n">local</span><span class="p">)</span>
                    <span class="k">await</span> <span class="n">wrapped</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">bot</span><span class="o">.</span><span class="n">dispatch</span><span class="p">(</span><span class="s1">&#39;command_error&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_actual_conversion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">converter</span><span class="p">,</span> <span class="n">argument</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">converter</span> <span class="ow">is</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">argument</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">module</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="vm">__module__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">module</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;discord.&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">module</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;converter&#39;</span><span class="p">)):</span>
                <span class="n">converter</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">converters</span><span class="p">,</span> <span class="n">converter</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;Converter&#39;</span><span class="p">,</span> <span class="n">converter</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">converter</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">converter</span><span class="p">,</span> <span class="n">converters</span><span class="o">.</span><span class="n">Converter</span><span class="p">):</span>
                    <span class="n">instance</span> <span class="o">=</span> <span class="n">converter</span><span class="p">()</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="k">await</span> <span class="n">instance</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">argument</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">ret</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">converter</span><span class="p">,</span> <span class="s1">&#39;convert&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
                        <span class="n">ret</span> <span class="o">=</span> <span class="k">await</span> <span class="n">method</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">argument</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">ret</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">converter</span><span class="p">,</span> <span class="n">converters</span><span class="o">.</span><span class="n">Converter</span><span class="p">):</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="k">await</span> <span class="n">converter</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">argument</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ret</span>
        <span class="k">except</span> <span class="n">CommandError</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ConversionError</span><span class="p">(</span><span class="n">converter</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">exc</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">converter</span><span class="p">(</span><span class="n">argument</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">CommandError</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

            <span class="k">raise</span> <span class="n">BadArgument</span><span class="p">(</span><span class="s1">&#39;Converting to &quot;</span><span class="si">{}</span><span class="s1">&quot; failed for parameter &quot;</span><span class="si">{}</span><span class="s1">&quot;.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">))</span> <span class="kn">from</span> <span class="nn">exc</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">do_conversion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">converter</span><span class="p">,</span> <span class="n">argument</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">__origin__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">:</span>
                <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">_NoneType</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">conv</span> <span class="ow">in</span> <span class="n">converter</span><span class="o">.</span><span class="n">__args__</span><span class="p">:</span>
                    <span class="c1"># if we got to this part in the code, then the previous conversions have failed</span>
                    <span class="c1"># so we should just undo the view, return the default, and allow parsing to continue</span>
                    <span class="c1"># with the other parameters</span>
                    <span class="k">if</span> <span class="n">conv</span> <span class="ow">is</span> <span class="n">_NoneType</span> <span class="ow">and</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">param</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">:</span>
                        <span class="n">ctx</span><span class="o">.</span><span class="n">view</span><span class="o">.</span><span class="n">undo</span><span class="p">()</span>
                        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">param</span><span class="o">.</span><span class="n">empty</span> <span class="k">else</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span>

                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_actual_conversion</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">conv</span><span class="p">,</span> <span class="n">argument</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
                    <span class="k">except</span> <span class="n">CommandError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                        <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">value</span>

                <span class="c1"># if we&#39;re  here, then we failed all the converters</span>
                <span class="k">raise</span> <span class="n">BadUnionArgument</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">converter</span><span class="o">.</span><span class="n">__args__</span><span class="p">,</span> <span class="n">errors</span><span class="p">)</span>

        <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_actual_conversion</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">converter</span><span class="p">,</span> <span class="n">argument</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_converter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
        <span class="n">converter</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">annotation</span>
        <span class="k">if</span> <span class="n">converter</span> <span class="ow">is</span> <span class="n">param</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">param</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">converter</span> <span class="o">=</span> <span class="nb">str</span> <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">type</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">default</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">converter</span> <span class="o">=</span> <span class="nb">str</span>
        <span class="k">return</span> <span class="n">converter</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
        <span class="n">required</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">param</span><span class="o">.</span><span class="n">empty</span>
        <span class="n">converter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_converter</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
        <span class="n">consume_rest_is_special</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">param</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_is_raw</span>
        <span class="n">view</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">view</span>
        <span class="n">view</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">()</span>

        <span class="c1"># The greedy converter is simple -- it keeps going until it fails in which case,</span>
        <span class="c1"># it undos the view ready for the next parameter to use instead</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">converter</span><span class="p">)</span> <span class="ow">is</span> <span class="n">converters</span><span class="o">.</span><span class="n">_Greedy</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">param</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span> <span class="ow">or</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">param</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span><span class="p">:</span>
                <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_greedy_pos</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">required</span><span class="p">,</span> <span class="n">converter</span><span class="o">.</span><span class="n">converter</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">param</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">:</span>
                <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_greedy_var_pos</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">converter</span><span class="o">.</span><span class="n">converter</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if we&#39;re here, then it&#39;s a KEYWORD_ONLY param type</span>
                <span class="c1"># since this is mostly useless, we&#39;ll helpfully transform Greedy[X]</span>
                <span class="c1"># into just X and do the parsing that way.</span>
                <span class="n">converter</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">converter</span>

        <span class="k">if</span> <span class="n">view</span><span class="o">.</span><span class="n">eof</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">param</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span> <span class="c1"># break the loop</span>
            <span class="k">if</span> <span class="n">required</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_typing_optional</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">annotation</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">raise</span> <span class="n">MissingRequiredArgument</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span>

        <span class="n">previous</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">index</span>
        <span class="k">if</span> <span class="n">consume_rest_is_special</span><span class="p">:</span>
            <span class="n">argument</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">read_rest</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">argument</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">get_quoted_word</span><span class="p">()</span>
        <span class="n">view</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="n">previous</span>

        <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_conversion</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">converter</span><span class="p">,</span> <span class="n">argument</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_transform_greedy_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">required</span><span class="p">,</span> <span class="n">converter</span><span class="p">):</span>
        <span class="n">view</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">view</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">view</span><span class="o">.</span><span class="n">eof</span><span class="p">:</span>
            <span class="c1"># for use with a manual undo</span>
            <span class="n">previous</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">index</span>

            <span class="n">view</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">argument</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">get_quoted_word</span><span class="p">()</span>
                <span class="n">value</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_conversion</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">converter</span><span class="p">,</span> <span class="n">argument</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="n">CommandError</span><span class="p">,</span> <span class="n">ArgumentParsingError</span><span class="p">):</span>
                <span class="n">view</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">previous</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">required</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_transform_greedy_var_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">converter</span><span class="p">):</span>
        <span class="n">view</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">view</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">index</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">argument</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">get_quoted_word</span><span class="p">()</span>
            <span class="n">value</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_conversion</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">converter</span><span class="p">,</span> <span class="n">argument</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">CommandError</span><span class="p">,</span> <span class="n">ArgumentParsingError</span><span class="p">):</span>
            <span class="n">view</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">previous</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span> <span class="kn">from</span> <span class="bp">None</span> <span class="c1"># break loop</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">clean_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;OrderedDict[:class:`str`, :class:`inspect.Parameter`]:</span>
<span class="sd">        Retrieves the parameter OrderedDict without the context or self parameters.</span>

<span class="sd">        Useful for inspecting signature.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># first parameter is self</span>
            <span class="n">result</span><span class="o">.</span><span class="n">popitem</span><span class="p">(</span><span class="n">last</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># first/second parameter is context</span>
            <span class="n">result</span><span class="o">.</span><span class="n">popitem</span><span class="p">(</span><span class="n">last</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Missing context parameter&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">full_parent_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:class:`str`: Retrieves the fully qualified parent command name.</span>

<span class="sd">        This the base command name required to execute it. For example,</span>
<span class="sd">        in ``?one two three`` the parent name would be ``one two``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">entries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">command</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">command</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">command</span> <span class="o">=</span> <span class="n">command</span><span class="o">.</span><span class="n">parent</span>
            <span class="n">entries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">command</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">entries</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List[:class:`Command`]: Retrieves the parents of this command.</span>

<span class="sd">        If the command has no parents then it returns an empty :class:`list`.</span>

<span class="sd">        For example in commands ``?a b c test``, the parents are ``[c, b, a]``.</span>

<span class="sd">        .. versionadded:: 1.1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">entries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">command</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">command</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">command</span> <span class="o">=</span> <span class="n">command</span><span class="o">.</span><span class="n">parent</span>
            <span class="n">entries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">entries</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">root_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optional[:class:`Command`]: Retrieves the root parent of this command.</span>

<span class="sd">        If the command has no parents then it returns ``None``.</span>

<span class="sd">        For example in commands ``?a b c test``, the root parent is ``a``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">qualified_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:class:`str`: Retrieves the fully qualified command name.</span>

<span class="sd">        This is the full parent name with the command name as well.</span>
<span class="sd">        For example, in ``?one two three`` the qualified name would be</span>
<span class="sd">        ``one two three``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_parent_name</span>
        <span class="k">if</span> <span class="n">parent</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">parent</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qualified_name</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_parse_arguments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">ctx</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cog</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cog</span><span class="p">,</span> <span class="n">ctx</span><span class="p">]</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">args</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">kwargs</span>

        <span class="n">view</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">view</span>
        <span class="n">iterator</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># we have &#39;self&#39; as the first parameter so just advance</span>
            <span class="c1"># the iterator and resume parsing</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;Callback for </span><span class="si">{0.name}</span><span class="s1"> command is missing &quot;self&quot; parameter.&#39;</span>
                <span class="k">raise</span> <span class="n">discord</span><span class="o">.</span><span class="n">ClientException</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="c1"># next we have the &#39;ctx&#39; as the next parameter</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;Callback for </span><span class="si">{0.name}</span><span class="s1"> command is missing &quot;ctx&quot; parameter.&#39;</span>
            <span class="k">raise</span> <span class="n">discord</span><span class="o">.</span><span class="n">ClientException</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">param</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span> <span class="ow">or</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">param</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span><span class="p">:</span>
                <span class="n">transformed</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
                <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">transformed</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">param</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span><span class="p">:</span>
                <span class="c1"># kwarg only param denotes &quot;consume rest&quot; semantics</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_is_raw</span><span class="p">:</span>
                    <span class="n">converter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_converter</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
                    <span class="n">argument</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">read_rest</span><span class="p">()</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_conversion</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">converter</span><span class="p">,</span> <span class="n">argument</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">param</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">view</span><span class="o">.</span><span class="n">eof</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_var_positional</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">MissingRequiredArgument</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="n">view</span><span class="o">.</span><span class="n">eof</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">transformed</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
                        <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">transformed</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
                        <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_extra</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">view</span><span class="o">.</span><span class="n">eof</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TooManyArguments</span><span class="p">(</span><span class="s1">&#39;Too many arguments passed to &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">qualified_name</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">call_before_hooks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="c1"># now that we&#39;re done preparing we can call the pre-command hooks</span>
        <span class="c1"># first, call the command local hook:</span>
        <span class="n">cog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cog</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_before_invoke</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># should be cog if @commands.before_invoke is used</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_before_invoke</span><span class="p">,</span> <span class="s1">&#39;__self__&#39;</span><span class="p">,</span> <span class="n">cog</span><span class="p">)</span>
            <span class="c1"># __self__ only exists for methods, not functions</span>
            <span class="c1"># however, if @command.before_invoke is used, it will be a function</span>
            <span class="k">if</span> <span class="n">instance</span><span class="p">:</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_before_invoke</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_before_invoke</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>

        <span class="c1"># call the cog local hook if applicable:</span>
        <span class="k">if</span> <span class="n">cog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hook</span> <span class="o">=</span> <span class="n">Cog</span><span class="o">.</span><span class="n">_get_overridden_method</span><span class="p">(</span><span class="n">cog</span><span class="o">.</span><span class="n">cog_before_invoke</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hook</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">hook</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>

        <span class="c1"># call the bot global hook if necessary</span>
        <span class="n">hook</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">bot</span><span class="o">.</span><span class="n">_before_invoke</span>
        <span class="k">if</span> <span class="n">hook</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">await</span> <span class="n">hook</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">call_after_hooks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="n">cog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cog</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_after_invoke</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_after_invoke</span><span class="p">,</span> <span class="s1">&#39;__self__&#39;</span><span class="p">,</span> <span class="n">cog</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">instance</span><span class="p">:</span>
                    <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_after_invoke</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_after_invoke</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>

        <span class="c1"># call the cog local hook if applicable:</span>
        <span class="k">if</span> <span class="n">cog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hook</span> <span class="o">=</span> <span class="n">Cog</span><span class="o">.</span><span class="n">_get_overridden_method</span><span class="p">(</span><span class="n">cog</span><span class="o">.</span><span class="n">cog_after_invoke</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hook</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">hook</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>

        <span class="n">hook</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">bot</span><span class="o">.</span><span class="n">_after_invoke</span>
        <span class="k">if</span> <span class="n">hook</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">await</span> <span class="n">hook</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_prepare_cooldowns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buckets</span><span class="o">.</span><span class="n">valid</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">edited_at</span> <span class="ow">or</span> <span class="n">ctx</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">created_at</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span><span class="o">.</span><span class="n">timestamp</span><span class="p">()</span>
            <span class="n">bucket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buckets</span><span class="o">.</span><span class="n">get_bucket</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">message</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
            <span class="n">retry_after</span> <span class="o">=</span> <span class="n">bucket</span><span class="o">.</span><span class="n">update_rate_limit</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">retry_after</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CommandOnCooldown</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="n">retry_after</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">command</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">can_run</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">CheckFailure</span><span class="p">(</span><span class="s1">&#39;The check functions for command </span><span class="si">{0.qualified_name}</span><span class="s1"> failed.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_concurrency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_concurrency</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cooldown_after_parsing</span><span class="p">:</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_arguments</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_cooldowns</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_cooldowns</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_arguments</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>

            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_before_hooks</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_concurrency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_concurrency</span><span class="o">.</span><span class="n">release</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
            <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">is_on_cooldown</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks whether the command is currently on cooldown.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        ctx: :class:`.Context`</span>
<span class="sd">            The invocation context to use when checking the commands cooldown status.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        :class:`bool`</span>
<span class="sd">            A boolean indicating if the command is on cooldown.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buckets</span><span class="o">.</span><span class="n">valid</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">bucket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buckets</span><span class="o">.</span><span class="n">get_bucket</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">edited_at</span> <span class="ow">or</span> <span class="n">ctx</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">created_at</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span><span class="o">.</span><span class="n">timestamp</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">bucket</span><span class="o">.</span><span class="n">get_tokens</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">reset_cooldown</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resets the cooldown on this command.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        ctx: :class:`.Context`</span>
<span class="sd">            The invocation context to reset the cooldown under.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buckets</span><span class="o">.</span><span class="n">valid</span><span class="p">:</span>
            <span class="n">bucket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buckets</span><span class="o">.</span><span class="n">get_bucket</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
            <span class="n">bucket</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_cooldown_retry_after</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieves the amount of seconds before this command can be tried again.</span>

<span class="sd">        .. versionadded:: 1.4</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        ctx: :class:`.Context`</span>
<span class="sd">            The invocation context to retrieve the cooldown from.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        :class:`float`</span>
<span class="sd">            The amount of time left on this command&#39;s cooldown in seconds.</span>
<span class="sd">            If this is ``0.0`` then the command isn&#39;t on cooldown.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buckets</span><span class="o">.</span><span class="n">valid</span><span class="p">:</span>
            <span class="n">bucket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buckets</span><span class="o">.</span><span class="n">get_bucket</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">edited_at</span> <span class="ow">or</span> <span class="n">ctx</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">created_at</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span><span class="o">.</span><span class="n">timestamp</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">bucket</span><span class="o">.</span><span class="n">get_retry_after</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>

        <span class="k">return</span> <span class="mf">0.0</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">invoke</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>

        <span class="c1"># terminate the invoked_subcommand chain.</span>
        <span class="c1"># since we&#39;re in a regular command (and not a group) then</span>
        <span class="c1"># the invoked subcommand is None.</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">invoked_subcommand</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">subcommand_passed</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">injected</span> <span class="o">=</span> <span class="n">hooked_wrapped_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">injected</span><span class="p">(</span><span class="o">*</span><span class="n">ctx</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">ctx</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">reinvoke</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">call_hooks</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">command</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_arguments</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">call_hooks</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_before_hooks</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>

        <span class="n">ctx</span><span class="o">.</span><span class="n">invoked_subcommand</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="o">*</span><span class="n">ctx</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">ctx</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">command_failed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">raise</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">call_hooks</span><span class="p">:</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_after_hooks</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coro</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A decorator that registers a coroutine as a local error handler.</span>

<span class="sd">        A local error handler is an :func:`.on_command_error` event limited to</span>
<span class="sd">        a single command. However, the :func:`.on_command_error` is still</span>
<span class="sd">        invoked afterwards as the catch-all.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        coro: :ref:`coroutine &lt;coroutine&gt;`</span>
<span class="sd">            The coroutine to register as the local error handler.</span>

<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        TypeError</span>
<span class="sd">            The coroutine passed is not actually a coroutine.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">iscoroutinefunction</span><span class="p">(</span><span class="n">coro</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The error handler must be a coroutine.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">on_error</span> <span class="o">=</span> <span class="n">coro</span>
        <span class="k">return</span> <span class="n">coro</span>

    <span class="k">def</span> <span class="nf">has_error_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:class:`bool`: Checks whether the command has an error handler registered.</span>

<span class="sd">        .. versionadded:: 1.7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;on_error&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">before_invoke</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coro</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A decorator that registers a coroutine as a pre-invoke hook.</span>

<span class="sd">        A pre-invoke hook is called directly before the command is</span>
<span class="sd">        called. This makes it a useful function to set up database</span>
<span class="sd">        connections or any type of set up required.</span>

<span class="sd">        This pre-invoke hook takes a sole parameter, a :class:`.Context`.</span>

<span class="sd">        See :meth:`.Bot.before_invoke` for more info.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        coro: :ref:`coroutine &lt;coroutine&gt;`</span>
<span class="sd">            The coroutine to register as the pre-invoke hook.</span>

<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        TypeError</span>
<span class="sd">            The coroutine passed is not actually a coroutine.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">iscoroutinefunction</span><span class="p">(</span><span class="n">coro</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The pre-invoke hook must be a coroutine.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_before_invoke</span> <span class="o">=</span> <span class="n">coro</span>
        <span class="k">return</span> <span class="n">coro</span>

    <span class="k">def</span> <span class="nf">after_invoke</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coro</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A decorator that registers a coroutine as a post-invoke hook.</span>

<span class="sd">        A post-invoke hook is called directly after the command is</span>
<span class="sd">        called. This makes it a useful function to clean-up database</span>
<span class="sd">        connections or any type of clean up required.</span>

<span class="sd">        This post-invoke hook takes a sole parameter, a :class:`.Context`.</span>

<span class="sd">        See :meth:`.Bot.after_invoke` for more info.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        coro: :ref:`coroutine &lt;coroutine&gt;`</span>
<span class="sd">            The coroutine to register as the post-invoke hook.</span>

<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        TypeError</span>
<span class="sd">            The coroutine passed is not actually a coroutine.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">iscoroutinefunction</span><span class="p">(</span><span class="n">coro</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The post-invoke hook must be a coroutine.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_after_invoke</span> <span class="o">=</span> <span class="n">coro</span>
        <span class="k">return</span> <span class="n">coro</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cog_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optional[:class:`str`]: The name of the cog this command belongs to, if any.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cog</span><span class="p">)</span><span class="o">.</span><span class="n">__cog_name__</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">short_doc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:class:`str`: Gets the &quot;short&quot; documentation of a command.</span>

<span class="sd">        By default, this is the :attr:`brief` attribute.</span>
<span class="sd">        If that lookup leads to an empty string then the first line of the</span>
<span class="sd">        :attr:`help` attribute is used instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">brief</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">brief</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">help</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">help</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">_is_typing_optional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotation</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">.</span><span class="n">__origin__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">annotation</span><span class="o">.</span><span class="n">__args__</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">signature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:class:`str`: Returns a POSIX-like signature useful for help command output.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">usage</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">usage</span>


        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clean_params</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">greedy</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">annotation</span><span class="p">,</span> <span class="n">converters</span><span class="o">.</span><span class="n">_Greedy</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">param</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="c1"># We don&#39;t want None or &#39;&#39; to trigger the [name=value] case and instead it should</span>
                <span class="c1"># do [name] since [name=None] or [name=] are not exactly useful for the user.</span>
                <span class="n">should_print</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">default</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">should_print</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">=</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">greedy</span> <span class="k">else</span>
                                  <span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">=</span><span class="si">%s</span><span class="s1">]...&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span><span class="p">))</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">param</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_var_positional</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&lt;</span><span class="si">%s</span><span class="s1">...&gt;&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">...]&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">greedy</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">]...&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_typing_optional</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">annotation</span><span class="p">):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&lt;</span><span class="si">%s</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">can_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;|coro|</span>

<span class="sd">        Checks if the command can be executed by checking all the predicates</span>
<span class="sd">        inside the :attr:`checks` attribute. This also checks whether the</span>
<span class="sd">        command is disabled.</span>

<span class="sd">        .. versionchanged:: 1.3</span>
<span class="sd">            Checks whether the command is disabled or not</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        ctx: :class:`.Context`</span>
<span class="sd">            The ctx of the command currently being invoked.</span>

<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`CommandError`</span>
<span class="sd">            Any command error that was raised during a check call will be propagated</span>
<span class="sd">            by this function.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        :class:`bool`</span>
<span class="sd">            A boolean indicating if the command can be invoked.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DisabledCommand</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0.name}</span><span class="s1"> command is disabled&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="n">original</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">command</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">command</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="k">await</span> <span class="n">ctx</span><span class="o">.</span><span class="n">bot</span><span class="o">.</span><span class="n">can_run</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">CheckFailure</span><span class="p">(</span><span class="s1">&#39;The global check functions for command </span><span class="si">{0.qualified_name}</span><span class="s1"> failed.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

            <span class="n">cog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cog</span>
            <span class="k">if</span> <span class="n">cog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">local_check</span> <span class="o">=</span> <span class="n">Cog</span><span class="o">.</span><span class="n">_get_overridden_method</span><span class="p">(</span><span class="n">cog</span><span class="o">.</span><span class="n">cog_check</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">local_check</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="k">await</span> <span class="n">discord</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">maybe_coroutine</span><span class="p">(</span><span class="n">local_check</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">ret</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>

            <span class="n">predicates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">checks</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">predicates</span><span class="p">:</span>
                <span class="c1"># since we have no checks, then we just return True.</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="k">return</span> <span class="k">await</span> <span class="n">discord</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">async_all</span><span class="p">(</span><span class="n">predicate</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="k">for</span> <span class="n">predicate</span> <span class="ow">in</span> <span class="n">predicates</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">original</span>

<span class="k">class</span> <span class="nc">GroupMixin</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A mixin that implements common functionality for classes that behave</span>
<span class="sd">    similar to :class:`.Group` and are allowed to register commands.</span>

<span class="sd">    Attributes</span>
<span class="sd">    -----------</span>
<span class="sd">    all_commands: :class:`dict`</span>
<span class="sd">        A mapping of command name to :class:`.Command`</span>
<span class="sd">        objects.</span>
<span class="sd">    case_insensitive: :class:`bool`</span>
<span class="sd">        Whether the commands should be case insensitive. Defaults to ``False``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">case_insensitive</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;case_insensitive&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_commands</span> <span class="o">=</span> <span class="n">_CaseInsensitiveDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">case_insensitive</span> <span class="k">else</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">case_insensitive</span> <span class="o">=</span> <span class="n">case_insensitive</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">commands</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set[:class:`.Command`]: A unique set of commands without aliases that are registered.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_commands</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">recursively_remove_all_commands</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">command</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_commands</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">GroupMixin</span><span class="p">):</span>
                <span class="n">command</span><span class="o">.</span><span class="n">recursively_remove_all_commands</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_command</span><span class="p">(</span><span class="n">command</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">command</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a :class:`.Command` into the internal list of commands.</span>

<span class="sd">        This is usually not called, instead the :meth:`~.GroupMixin.command` or</span>
<span class="sd">        :meth:`~.GroupMixin.group` shortcut decorators are used instead.</span>

<span class="sd">        .. versionchanged:: 1.4</span>
<span class="sd">             Raise :exc:`.CommandRegistrationError` instead of generic :exc:`.ClientException`</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        command: :class:`Command`</span>
<span class="sd">            The command to add.</span>

<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        :exc:`.CommandRegistrationError`</span>
<span class="sd">            If the command or its alias is already registered by different command.</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the command passed is not a subclass of :class:`.Command`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">Command</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The command passed must be a subclass of Command&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Command</span><span class="p">):</span>
            <span class="n">command</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">command</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_commands</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CommandRegistrationError</span><span class="p">(</span><span class="n">command</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">all_commands</span><span class="p">[</span><span class="n">command</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">command</span>
        <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">command</span><span class="o">.</span><span class="n">aliases</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">alias</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_commands</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove_command</span><span class="p">(</span><span class="n">command</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">CommandRegistrationError</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">alias_conflict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_commands</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span> <span class="o">=</span> <span class="n">command</span>

    <span class="k">def</span> <span class="nf">remove_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove a :class:`.Command` from the internal list</span>
<span class="sd">        of commands.</span>

<span class="sd">        This could also be used as a way to remove aliases.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        name: :class:`str`</span>
<span class="sd">            The name of the command to remove.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        Optional[:class:`.Command`]</span>
<span class="sd">            The command that was removed. If the name is not valid then</span>
<span class="sd">            ``None`` is returned instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">command</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_commands</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># does not exist</span>
        <span class="k">if</span> <span class="n">command</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">command</span><span class="o">.</span><span class="n">aliases</span><span class="p">:</span>
            <span class="c1"># we&#39;re removing an alias so we don&#39;t want to remove the rest</span>
            <span class="k">return</span> <span class="n">command</span>

        <span class="c1"># we&#39;re not removing the alias so let&#39;s delete the rest of them.</span>
        <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">command</span><span class="o">.</span><span class="n">aliases</span><span class="p">:</span>
            <span class="n">cmd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_commands</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="c1"># in the case of a CommandRegistrationError, an alias might conflict</span>
            <span class="c1"># with an already existing command. If this is the case, we want to</span>
            <span class="c1"># make sure the pre-existing command is not removed.</span>
            <span class="k">if</span> <span class="n">cmd</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">command</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_commands</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmd</span>
        <span class="k">return</span> <span class="n">command</span>

    <span class="k">def</span> <span class="nf">walk_commands</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An iterator that recursively walks through all commands and subcommands.</span>

<span class="sd">        .. versionchanged:: 1.4</span>
<span class="sd">            Duplicates due to aliases are no longer returned</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        Union[:class:`.Command`, :class:`.Group`]</span>
<span class="sd">            A command or group from the internal list of commands.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">command</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">commands</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">command</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">GroupMixin</span><span class="p">):</span>
                <span class="k">yield from</span> <span class="n">command</span><span class="o">.</span><span class="n">walk_commands</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a :class:`.Command` from the internal list</span>
<span class="sd">        of commands.</span>

<span class="sd">        This could also be used as a way to get aliases.</span>

<span class="sd">        The name could be fully qualified (e.g. ``&#39;foo bar&#39;``) will get</span>
<span class="sd">        the subcommand ``bar`` of the group command ``foo``. If a</span>
<span class="sd">        subcommand is not found then ``None`` is returned just as usual.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        name: :class:`str`</span>
<span class="sd">            The name of the command to get.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        Optional[:class:`Command`]</span>
<span class="sd">            The command that was requested. If not found, returns ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># fast path, no space in name.</span>
        <span class="k">if</span> <span class="s1">&#39; &#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_commands</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="n">names</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_commands</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">GroupMixin</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">all_commands</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A shortcut decorator that invokes :func:`.command` and adds it to</span>
<span class="sd">        the internal command list via :meth:`~.GroupMixin.add_command`.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        Callable[..., :class:`Command`]</span>
<span class="sd">            A decorator that converts the provided method into a Command, adds it to the bot, then returns it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;parent&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">command</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)(</span><span class="n">func</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_command</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">return</span> <span class="n">decorator</span>

    <span class="k">def</span> <span class="nf">group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A shortcut decorator that invokes :func:`.group` and adds it to</span>
<span class="sd">        the internal command list via :meth:`~.GroupMixin.add_command`.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        Callable[..., :class:`Group`]</span>
<span class="sd">            A decorator that converts the provided method into a Group, adds it to the bot, then returns it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;parent&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">group</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)(</span><span class="n">func</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_command</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">return</span> <span class="n">decorator</span>

<span class="k">class</span> <span class="nc">Group</span><span class="p">(</span><span class="n">GroupMixin</span><span class="p">,</span> <span class="n">Command</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class that implements a grouping protocol for commands to be</span>
<span class="sd">    executed as subcommands.</span>

<span class="sd">    This class is a subclass of :class:`.Command` and thus all options</span>
<span class="sd">    valid in :class:`.Command` are valid in here as well.</span>

<span class="sd">    Attributes</span>
<span class="sd">    -----------</span>
<span class="sd">    invoke_without_command: :class:`bool`</span>
<span class="sd">        Indicates if the group callback should begin parsing and</span>
<span class="sd">        invocation only if no subcommand was found. Useful for</span>
<span class="sd">        making it an error handling function to tell the user that</span>
<span class="sd">        no subcommand was found or to have different functionality</span>
<span class="sd">        in case no subcommand was found. If this is ``False``, then</span>
<span class="sd">        the group callback will always be invoked first. This means</span>
<span class="sd">        that the checks and the parsing dictated by its parameters</span>
<span class="sd">        will be executed. Defaults to ``False``.</span>
<span class="sd">    case_insensitive: :class:`bool`</span>
<span class="sd">        Indicates if the group&#39;s commands should be case insensitive.</span>
<span class="sd">        Defaults to ``False``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">attrs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invoke_without_command</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;invoke_without_command&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">attrs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a copy of this :class:`Group`.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        :class:`Group`</span>
<span class="sd">            A new instance of this group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">cmd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">commands</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">add_command</span><span class="p">(</span><span class="n">cmd</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">invoke</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">invoked_subcommand</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">subcommand_passed</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">early_invoke</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">invoke_without_command</span>
        <span class="k">if</span> <span class="n">early_invoke</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>

        <span class="n">view</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">view</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">index</span>
        <span class="n">view</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">()</span>
        <span class="n">trigger</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">get_word</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">trigger</span><span class="p">:</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">subcommand_passed</span> <span class="o">=</span> <span class="n">trigger</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">invoked_subcommand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_commands</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">trigger</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">early_invoke</span><span class="p">:</span>
            <span class="n">injected</span> <span class="o">=</span> <span class="n">hooked_wrapped_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">)</span>
            <span class="k">await</span> <span class="n">injected</span><span class="p">(</span><span class="o">*</span><span class="n">ctx</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">ctx</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">ctx</span><span class="o">.</span><span class="n">invoked_parents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">invoked_with</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">trigger</span> <span class="ow">and</span> <span class="n">ctx</span><span class="o">.</span><span class="n">invoked_subcommand</span><span class="p">:</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">invoked_with</span> <span class="o">=</span> <span class="n">trigger</span>
            <span class="k">await</span> <span class="n">ctx</span><span class="o">.</span><span class="n">invoked_subcommand</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">early_invoke</span><span class="p">:</span>
            <span class="c1"># undo the trigger parsing</span>
            <span class="n">view</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">previous</span>
            <span class="n">view</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="n">previous</span>
            <span class="k">await</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">reinvoke</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">call_hooks</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">invoked_subcommand</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">early_invoke</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">invoke_without_command</span>
        <span class="k">if</span> <span class="n">early_invoke</span><span class="p">:</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">command</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_arguments</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">call_hooks</span><span class="p">:</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_before_hooks</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>

        <span class="n">view</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">view</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">index</span>
        <span class="n">view</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">()</span>
        <span class="n">trigger</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">get_word</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">trigger</span><span class="p">:</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">subcommand_passed</span> <span class="o">=</span> <span class="n">trigger</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">invoked_subcommand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_commands</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">trigger</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">early_invoke</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="o">*</span><span class="n">ctx</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">ctx</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">ctx</span><span class="o">.</span><span class="n">command_failed</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">raise</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">call_hooks</span><span class="p">:</span>
                    <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_after_hooks</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>

        <span class="n">ctx</span><span class="o">.</span><span class="n">invoked_parents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">invoked_with</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">trigger</span> <span class="ow">and</span> <span class="n">ctx</span><span class="o">.</span><span class="n">invoked_subcommand</span><span class="p">:</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">invoked_with</span> <span class="o">=</span> <span class="n">trigger</span>
            <span class="k">await</span> <span class="n">ctx</span><span class="o">.</span><span class="n">invoked_subcommand</span><span class="o">.</span><span class="n">reinvoke</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">call_hooks</span><span class="o">=</span><span class="n">call_hooks</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">early_invoke</span><span class="p">:</span>
            <span class="c1"># undo the trigger parsing</span>
            <span class="n">view</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">previous</span>
            <span class="n">view</span><span class="o">.</span><span class="n">previous</span> <span class="o">=</span> <span class="n">previous</span>
            <span class="k">await</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">reinvoke</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">call_hooks</span><span class="o">=</span><span class="n">call_hooks</span><span class="p">)</span>

<span class="c1"># Decorators</span>

<span class="k">def</span> <span class="nf">command</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">attrs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A decorator that transforms a function into a :class:`.Command`</span>
<span class="sd">    or if called with :func:`.group`, :class:`.Group`.</span>

<span class="sd">    By default the ``help`` attribute is received automatically from the</span>
<span class="sd">    docstring of the function and is cleaned up with the use of</span>
<span class="sd">    ``inspect.cleandoc``. If the docstring is ``bytes``, then it is decoded</span>
<span class="sd">    into :class:`str` using utf-8 encoding.</span>

<span class="sd">    All checks added using the :func:`.check` &amp; co. decorators are added into</span>
<span class="sd">    the function. There is no way to supply your own checks through this</span>
<span class="sd">    decorator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    name: :class:`str`</span>
<span class="sd">        The name to create the command with. By default this uses the</span>
<span class="sd">        function name unchanged.</span>
<span class="sd">    cls</span>
<span class="sd">        The class to construct with. By default this is :class:`.Command`.</span>
<span class="sd">        You usually do not change this.</span>
<span class="sd">    attrs</span>
<span class="sd">        Keyword arguments to pass into the construction of the class denoted</span>
<span class="sd">        by ``cls``.</span>

<span class="sd">    Raises</span>
<span class="sd">    -------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If the function is not a coroutine or is already a command.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">Command</span>

    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">Command</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Callback is already a command.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">attrs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">decorator</span>

<span class="k">def</span> <span class="nf">group</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">attrs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A decorator that transforms a function into a :class:`.Group`.</span>

<span class="sd">    This is similar to the :func:`.command` decorator but the ``cls``</span>
<span class="sd">    parameter is set to :class:`Group` by default.</span>

<span class="sd">    .. versionchanged:: 1.1</span>
<span class="sd">        The ``cls`` parameter can now be passed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">attrs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;cls&#39;</span><span class="p">,</span> <span class="n">Group</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">command</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">attrs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">predicate</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;A decorator that adds a check to the :class:`.Command` or its</span>
<span class="sd">    subclasses. These checks could be accessed via :attr:`.Command.checks`.</span>

<span class="sd">    These checks should be predicates that take in a single parameter taking</span>
<span class="sd">    a :class:`.Context`. If the check returns a ``False``\-like value then</span>
<span class="sd">    during invocation a :exc:`.CheckFailure` exception is raised and sent to</span>
<span class="sd">    the :func:`.on_command_error` event.</span>

<span class="sd">    If an exception should be thrown in the predicate then it should be a</span>
<span class="sd">    subclass of :exc:`.CommandError`. Any exception not subclassed from it</span>
<span class="sd">    will be propagated while those subclassed will be sent to</span>
<span class="sd">    :func:`.on_command_error`.</span>

<span class="sd">    A special attribute named ``predicate`` is bound to the value</span>
<span class="sd">    returned by this decorator to retrieve the predicate passed to the</span>
<span class="sd">    decorator. This allows the following introspection and chaining to be done:</span>

<span class="sd">    .. code-block:: python3</span>

<span class="sd">        def owner_or_permissions(**perms):</span>
<span class="sd">            original = commands.has_permissions(**perms).predicate</span>
<span class="sd">            async def extended_check(ctx):</span>
<span class="sd">                if ctx.guild is None:</span>
<span class="sd">                    return False</span>
<span class="sd">                return ctx.guild.owner_id == ctx.author.id or await original(ctx)</span>
<span class="sd">            return commands.check(extended_check)</span>

<span class="sd">    .. note::</span>

<span class="sd">        The function returned by ``predicate`` is **always** a coroutine,</span>
<span class="sd">        even if the original function was not a coroutine.</span>

<span class="sd">    .. versionchanged:: 1.3</span>
<span class="sd">        The ``predicate`` attribute was added.</span>

<span class="sd">    Examples</span>
<span class="sd">    ---------</span>

<span class="sd">    Creating a basic check to see if the command invoker is you.</span>

<span class="sd">    .. code-block:: python3</span>

<span class="sd">        def check_if_it_is_me(ctx):</span>
<span class="sd">            return ctx.message.author.id == 85309593344815104</span>

<span class="sd">        @bot.command()</span>
<span class="sd">        @commands.check(check_if_it_is_me)</span>
<span class="sd">        async def only_for_me(ctx):</span>
<span class="sd">            await ctx.send(&#39;I know you!&#39;)</span>

<span class="sd">    Transforming common checks into its own decorator:</span>

<span class="sd">    .. code-block:: python3</span>

<span class="sd">        def is_me():</span>
<span class="sd">            def predicate(ctx):</span>
<span class="sd">                return ctx.message.author.id == 85309593344815104</span>
<span class="sd">            return commands.check(predicate)</span>

<span class="sd">        @bot.command()</span>
<span class="sd">        @is_me()</span>
<span class="sd">        async def only_me(ctx):</span>
<span class="sd">            await ctx.send(&#39;Only you!&#39;)</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    predicate: Callable[[:class:`Context`], :class:`bool`]</span>
<span class="sd">        The predicate to check if the command should be invoked.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">Command</span><span class="p">):</span>
            <span class="n">func</span><span class="o">.</span><span class="n">checks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">predicate</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;__commands_checks__&#39;</span><span class="p">):</span>
                <span class="n">func</span><span class="o">.</span><span class="n">__commands_checks__</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">func</span><span class="o">.</span><span class="n">__commands_checks__</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">predicate</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">func</span>

    <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">iscoroutinefunction</span><span class="p">(</span><span class="n">predicate</span><span class="p">):</span>
        <span class="n">decorator</span><span class="o">.</span><span class="n">predicate</span> <span class="o">=</span> <span class="n">predicate</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">predicate</span><span class="p">)</span>
        <span class="k">async</span> <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">predicate</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="n">decorator</span><span class="o">.</span><span class="n">predicate</span> <span class="o">=</span> <span class="n">wrapper</span>

    <span class="k">return</span> <span class="n">decorator</span>

<span class="k">def</span> <span class="nf">check_any</span><span class="p">(</span><span class="o">*</span><span class="n">checks</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;A :func:`check` that is added that checks if any of the checks passed</span>
<span class="sd">    will pass, i.e. using logical OR.</span>

<span class="sd">    If all checks fail then :exc:`.CheckAnyFailure` is raised to signal the failure.</span>
<span class="sd">    It inherits from :exc:`.CheckFailure`.</span>

<span class="sd">    .. note::</span>

<span class="sd">        The ``predicate`` attribute for this function **is** a coroutine.</span>

<span class="sd">    .. versionadded:: 1.3</span>

<span class="sd">    Parameters</span>
<span class="sd">    ------------</span>
<span class="sd">    \*checks: Callable[[:class:`Context`], :class:`bool`]</span>
<span class="sd">        An argument list of checks that have been decorated with</span>
<span class="sd">        the :func:`check` decorator.</span>

<span class="sd">    Raises</span>
<span class="sd">    -------</span>
<span class="sd">    TypeError</span>
<span class="sd">        A check passed has not been decorated with the :func:`check`</span>
<span class="sd">        decorator.</span>

<span class="sd">    Examples</span>
<span class="sd">    ---------</span>

<span class="sd">    Creating a basic check to see if it&#39;s the bot owner or</span>
<span class="sd">    the server owner:</span>

<span class="sd">    .. code-block:: python3</span>

<span class="sd">        def is_guild_owner():</span>
<span class="sd">            def predicate(ctx):</span>
<span class="sd">                return ctx.guild is not None and ctx.guild.owner_id == ctx.author.id</span>
<span class="sd">            return commands.check(predicate)</span>

<span class="sd">        @bot.command()</span>
<span class="sd">        @commands.check_any(commands.is_owner(), is_guild_owner())</span>
<span class="sd">        async def only_for_owners(ctx):</span>
<span class="sd">            await ctx.send(&#39;Hello mister owner!&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">unwrapped</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">wrapped</span> <span class="ow">in</span> <span class="n">checks</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">wrapped</span><span class="o">.</span><span class="n">predicate</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%r</span><span class="s1"> must be wrapped by commands.check decorator&#39;</span> <span class="o">%</span> <span class="n">wrapped</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unwrapped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">predicate</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">unwrapped</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="k">await</span> <span class="n">func</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">CheckFailure</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="c1"># if we&#39;re here, all checks failed</span>
        <span class="k">raise</span> <span class="n">CheckAnyFailure</span><span class="p">(</span><span class="n">unwrapped</span><span class="p">,</span> <span class="n">errors</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">check</span><span class="p">(</span><span class="n">predicate</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">has_role</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A :func:`.check` that is added that checks if the member invoking the</span>
<span class="sd">    command has the role specified via the name or ID specified.</span>

<span class="sd">    If a string is specified, you must give the exact name of the role, including</span>
<span class="sd">    caps and spelling.</span>

<span class="sd">    If an integer is specified, you must give the exact snowflake ID of the role.</span>

<span class="sd">    If the message is invoked in a private message context then the check will</span>
<span class="sd">    return ``False``.</span>

<span class="sd">    This check raises one of two special exceptions, :exc:`.MissingRole` if the user</span>
<span class="sd">    is missing a role, or :exc:`.NoPrivateMessage` if it is used in a private message.</span>
<span class="sd">    Both inherit from :exc:`.CheckFailure`.</span>

<span class="sd">    .. versionchanged:: 1.1</span>

<span class="sd">        Raise :exc:`.MissingRole` or :exc:`.NoPrivateMessage`</span>
<span class="sd">        instead of generic :exc:`.CheckFailure`</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    item: Union[:class:`int`, :class:`str`]</span>
<span class="sd">        The name or ID of the role to check.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">predicate</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">channel</span><span class="p">,</span> <span class="n">discord</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">GuildChannel</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">NoPrivateMessage</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">role</span> <span class="o">=</span> <span class="n">discord</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">author</span><span class="o">.</span><span class="n">roles</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">item</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">role</span> <span class="o">=</span> <span class="n">discord</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">author</span><span class="o">.</span><span class="n">roles</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">item</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">role</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MissingRole</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">check</span><span class="p">(</span><span class="n">predicate</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">has_any_role</span><span class="p">(</span><span class="o">*</span><span class="n">items</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;A :func:`.check` that is added that checks if the member invoking the</span>
<span class="sd">    command has **any** of the roles specified. This means that if they have</span>
<span class="sd">    one out of the three roles specified, then this check will return `True`.</span>

<span class="sd">    Similar to :func:`.has_role`\, the names or IDs passed in must be exact.</span>

<span class="sd">    This check raises one of two special exceptions, :exc:`.MissingAnyRole` if the user</span>
<span class="sd">    is missing all roles, or :exc:`.NoPrivateMessage` if it is used in a private message.</span>
<span class="sd">    Both inherit from :exc:`.CheckFailure`.</span>

<span class="sd">    .. versionchanged:: 1.1</span>

<span class="sd">        Raise :exc:`.MissingAnyRole` or :exc:`.NoPrivateMessage`</span>
<span class="sd">        instead of generic :exc:`.CheckFailure`</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    items: List[Union[:class:`str`, :class:`int`]]</span>
<span class="sd">        An argument list of names or IDs to check that the member has roles wise.</span>

<span class="sd">    Example</span>
<span class="sd">    --------</span>

<span class="sd">    .. code-block:: python3</span>

<span class="sd">        @bot.command()</span>
<span class="sd">        @commands.has_any_role(&#39;Library Devs&#39;, &#39;Moderators&#39;, 492212595072434186)</span>
<span class="sd">        async def cool(ctx):</span>
<span class="sd">            await ctx.send(&#39;You are cool indeed&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">predicate</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">channel</span><span class="p">,</span> <span class="n">discord</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">GuildChannel</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">NoPrivateMessage</span><span class="p">()</span>

        <span class="n">getter</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">discord</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="n">ctx</span><span class="o">.</span><span class="n">author</span><span class="o">.</span><span class="n">roles</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">getter</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">item</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">else</span> <span class="n">getter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">item</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">raise</span> <span class="n">MissingAnyRole</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">check</span><span class="p">(</span><span class="n">predicate</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">bot_has_role</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Similar to :func:`.has_role` except checks if the bot itself has the</span>
<span class="sd">    role.</span>

<span class="sd">    This check raises one of two special exceptions, :exc:`.BotMissingRole` if the bot</span>
<span class="sd">    is missing the role, or :exc:`.NoPrivateMessage` if it is used in a private message.</span>
<span class="sd">    Both inherit from :exc:`.CheckFailure`.</span>

<span class="sd">    .. versionchanged:: 1.1</span>

<span class="sd">        Raise :exc:`.BotMissingRole` or :exc:`.NoPrivateMessage`</span>
<span class="sd">        instead of generic :exc:`.CheckFailure`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">predicate</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">channel</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">discord</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">GuildChannel</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">NoPrivateMessage</span><span class="p">()</span>

        <span class="n">me</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">guild</span><span class="o">.</span><span class="n">me</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">role</span> <span class="o">=</span> <span class="n">discord</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">me</span><span class="o">.</span><span class="n">roles</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">item</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">role</span> <span class="o">=</span> <span class="n">discord</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">me</span><span class="o">.</span><span class="n">roles</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">item</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">role</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">BotMissingRole</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">check</span><span class="p">(</span><span class="n">predicate</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">bot_has_any_role</span><span class="p">(</span><span class="o">*</span><span class="n">items</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Similar to :func:`.has_any_role` except checks if the bot itself has</span>
<span class="sd">    any of the roles listed.</span>

<span class="sd">    This check raises one of two special exceptions, :exc:`.BotMissingAnyRole` if the bot</span>
<span class="sd">    is missing all roles, or :exc:`.NoPrivateMessage` if it is used in a private message.</span>
<span class="sd">    Both inherit from :exc:`.CheckFailure`.</span>

<span class="sd">    .. versionchanged:: 1.1</span>

<span class="sd">        Raise :exc:`.BotMissingAnyRole` or :exc:`.NoPrivateMessage`</span>
<span class="sd">        instead of generic checkfailure</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">predicate</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">channel</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">discord</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">GuildChannel</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">NoPrivateMessage</span><span class="p">()</span>

        <span class="n">me</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">guild</span><span class="o">.</span><span class="n">me</span>
        <span class="n">getter</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">discord</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="n">me</span><span class="o">.</span><span class="n">roles</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">getter</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">item</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">else</span> <span class="n">getter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">item</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">raise</span> <span class="n">BotMissingAnyRole</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">check</span><span class="p">(</span><span class="n">predicate</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">has_permissions</span><span class="p">(</span><span class="o">**</span><span class="n">perms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A :func:`.check` that is added that checks if the member has all of</span>
<span class="sd">    the permissions necessary.</span>

<span class="sd">    Note that this check operates on the current channel permissions, not the</span>
<span class="sd">    guild wide permissions.</span>

<span class="sd">    The permissions passed in must be exactly like the properties shown under</span>
<span class="sd">    :class:`.discord.Permissions`.</span>

<span class="sd">    This check raises a special exception, :exc:`.MissingPermissions`</span>
<span class="sd">    that is inherited from :exc:`.CheckFailure`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ------------</span>
<span class="sd">    perms</span>
<span class="sd">        An argument list of permissions to check for.</span>

<span class="sd">    Example</span>
<span class="sd">    ---------</span>

<span class="sd">    .. code-block:: python3</span>

<span class="sd">        @bot.command()</span>
<span class="sd">        @commands.has_permissions(manage_messages=True)</span>
<span class="sd">        async def test(ctx):</span>
<span class="sd">            await ctx.send(&#39;You can manage messages.&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">invalid</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">perms</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">discord</span><span class="o">.</span><span class="n">Permissions</span><span class="o">.</span><span class="n">VALID_FLAGS</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">invalid</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid permission(s): </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invalid</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">predicate</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">channel</span>
        <span class="n">permissions</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">permissions_for</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">author</span><span class="p">)</span>

        <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">perm</span> <span class="k">for</span> <span class="n">perm</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">perms</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">permissions</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span> <span class="o">!=</span> <span class="n">value</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">missing</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">raise</span> <span class="n">MissingPermissions</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">check</span><span class="p">(</span><span class="n">predicate</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">bot_has_permissions</span><span class="p">(</span><span class="o">**</span><span class="n">perms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Similar to :func:`.has_permissions` except checks if the bot itself has</span>
<span class="sd">    the permissions listed.</span>

<span class="sd">    This check raises a special exception, :exc:`.BotMissingPermissions`</span>
<span class="sd">    that is inherited from :exc:`.CheckFailure`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">invalid</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">perms</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">discord</span><span class="o">.</span><span class="n">Permissions</span><span class="o">.</span><span class="n">VALID_FLAGS</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">invalid</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid permission(s): </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invalid</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">predicate</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
        <span class="n">guild</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">guild</span>
        <span class="n">me</span> <span class="o">=</span> <span class="n">guild</span><span class="o">.</span><span class="n">me</span> <span class="k">if</span> <span class="n">guild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ctx</span><span class="o">.</span><span class="n">bot</span><span class="o">.</span><span class="n">user</span>
        <span class="n">permissions</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">permissions_for</span><span class="p">(</span><span class="n">me</span><span class="p">)</span>

        <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">perm</span> <span class="k">for</span> <span class="n">perm</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">perms</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">permissions</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span> <span class="o">!=</span> <span class="n">value</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">missing</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">raise</span> <span class="n">BotMissingPermissions</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">check</span><span class="p">(</span><span class="n">predicate</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">has_guild_permissions</span><span class="p">(</span><span class="o">**</span><span class="n">perms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Similar to :func:`.has_permissions`, but operates on guild wide</span>
<span class="sd">    permissions instead of the current channel permissions.</span>

<span class="sd">    If this check is called in a DM context, it will raise an</span>
<span class="sd">    exception, :exc:`.NoPrivateMessage`.</span>

<span class="sd">    .. versionadded:: 1.3</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">invalid</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">perms</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">discord</span><span class="o">.</span><span class="n">Permissions</span><span class="o">.</span><span class="n">VALID_FLAGS</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">invalid</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid permission(s): </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invalid</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">predicate</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ctx</span><span class="o">.</span><span class="n">guild</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoPrivateMessage</span>

        <span class="n">permissions</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">author</span><span class="o">.</span><span class="n">guild_permissions</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">perm</span> <span class="k">for</span> <span class="n">perm</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">perms</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">permissions</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span> <span class="o">!=</span> <span class="n">value</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">missing</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">raise</span> <span class="n">MissingPermissions</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">check</span><span class="p">(</span><span class="n">predicate</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">bot_has_guild_permissions</span><span class="p">(</span><span class="o">**</span><span class="n">perms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Similar to :func:`.has_guild_permissions`, but checks the bot</span>
<span class="sd">    members guild permissions.</span>

<span class="sd">    .. versionadded:: 1.3</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">invalid</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">perms</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">discord</span><span class="o">.</span><span class="n">Permissions</span><span class="o">.</span><span class="n">VALID_FLAGS</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">invalid</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid permission(s): </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">invalid</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">predicate</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ctx</span><span class="o">.</span><span class="n">guild</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoPrivateMessage</span>

        <span class="n">permissions</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">me</span><span class="o">.</span><span class="n">guild_permissions</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">perm</span> <span class="k">for</span> <span class="n">perm</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">perms</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">permissions</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span> <span class="o">!=</span> <span class="n">value</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">missing</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">raise</span> <span class="n">BotMissingPermissions</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">check</span><span class="p">(</span><span class="n">predicate</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dm_only</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;A :func:`.check` that indicates this command must only be used in a</span>
<span class="sd">    DM context. Only private messages are allowed when</span>
<span class="sd">    using the command.</span>

<span class="sd">    This check raises a special exception, :exc:`.PrivateMessageOnly`</span>
<span class="sd">    that is inherited from :exc:`.CheckFailure`.</span>

<span class="sd">    .. versionadded:: 1.1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">predicate</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ctx</span><span class="o">.</span><span class="n">guild</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">PrivateMessageOnly</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">check</span><span class="p">(</span><span class="n">predicate</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">guild_only</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;A :func:`.check` that indicates this command must only be used in a</span>
<span class="sd">    guild context only. Basically, no private messages are allowed when</span>
<span class="sd">    using the command.</span>

<span class="sd">    This check raises a special exception, :exc:`.NoPrivateMessage`</span>
<span class="sd">    that is inherited from :exc:`.CheckFailure`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">predicate</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ctx</span><span class="o">.</span><span class="n">guild</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoPrivateMessage</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">check</span><span class="p">(</span><span class="n">predicate</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">is_owner</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;A :func:`.check` that checks if the person invoking this command is the</span>
<span class="sd">    owner of the bot.</span>

<span class="sd">    This is powered by :meth:`.Bot.is_owner`.</span>

<span class="sd">    This check raises a special exception, :exc:`.NotOwner` that is derived</span>
<span class="sd">    from :exc:`.CheckFailure`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">predicate</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="k">await</span> <span class="n">ctx</span><span class="o">.</span><span class="n">bot</span><span class="o">.</span><span class="n">is_owner</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">author</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">NotOwner</span><span class="p">(</span><span class="s1">&#39;You do not own this bot.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">check</span><span class="p">(</span><span class="n">predicate</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">is_nsfw</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;A :func:`.check` that checks if the channel is a NSFW channel.</span>

<span class="sd">    This check raises a special exception, :exc:`.NSFWChannelRequired`</span>
<span class="sd">    that is derived from :exc:`.CheckFailure`.</span>

<span class="sd">    .. versionchanged:: 1.1</span>

<span class="sd">        Raise :exc:`.NSFWChannelRequired` instead of generic :exc:`.CheckFailure`.</span>
<span class="sd">        DM channels will also now pass this check.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">pred</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">channel</span>
        <span class="k">if</span> <span class="n">ctx</span><span class="o">.</span><span class="n">guild</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">discord</span><span class="o">.</span><span class="n">TextChannel</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ch</span><span class="o">.</span><span class="n">is_nsfw</span><span class="p">()):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">raise</span> <span class="n">NSFWChannelRequired</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">check</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cooldown</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="n">per</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">BucketType</span><span class="o">.</span><span class="n">default</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A decorator that adds a cooldown to a :class:`.Command`</span>

<span class="sd">    A cooldown allows a command to only be used a specific amount</span>
<span class="sd">    of times in a specific time frame. These cooldowns can be based</span>
<span class="sd">    either on a per-guild, per-channel, per-user, per-role or global basis.</span>
<span class="sd">    Denoted by the third argument of ``type`` which must be of enum</span>
<span class="sd">    type :class:`.BucketType`.</span>

<span class="sd">    If a cooldown is triggered, then :exc:`.CommandOnCooldown` is triggered in</span>
<span class="sd">    :func:`.on_command_error` and the local error handler.</span>

<span class="sd">    A command can only have a single cooldown.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ------------</span>
<span class="sd">    rate: :class:`int`</span>
<span class="sd">        The number of times a command can be used before triggering a cooldown.</span>
<span class="sd">    per: :class:`float`</span>
<span class="sd">        The amount of seconds to wait for a cooldown when it&#39;s been triggered.</span>
<span class="sd">    type: Union[:class:`.BucketType`, Callable[[:class:`.Message`], Any]]</span>
<span class="sd">        The type of cooldown to have. If callable, should return a key for the mapping.</span>
<span class="sd">        </span>
<span class="sd">        .. versionchanged:: 1.7</span>
<span class="sd">            Callables are now supported for custom bucket types.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">Command</span><span class="p">):</span>
            <span class="n">func</span><span class="o">.</span><span class="n">_buckets</span> <span class="o">=</span> <span class="n">CooldownMapping</span><span class="p">(</span><span class="n">Cooldown</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="n">per</span><span class="p">,</span> <span class="nb">type</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">func</span><span class="o">.</span><span class="n">__commands_cooldown__</span> <span class="o">=</span> <span class="n">Cooldown</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="n">per</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">decorator</span>

<span class="k">def</span> <span class="nf">max_concurrency</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">per</span><span class="o">=</span><span class="n">BucketType</span><span class="o">.</span><span class="n">default</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A decorator that adds a maximum concurrency to a :class:`.Command` or its subclasses.</span>

<span class="sd">    This enables you to only allow a certain number of command invocations at the same time,</span>
<span class="sd">    for example if a command takes too long or if only one user can use it at a time. This</span>
<span class="sd">    differs from a cooldown in that there is no set waiting period or token bucket -- only</span>
<span class="sd">    a set number of people can run the command.</span>

<span class="sd">    .. versionadded:: 1.3</span>

<span class="sd">    Parameters</span>
<span class="sd">    -------------</span>
<span class="sd">    number: :class:`int`</span>
<span class="sd">        The maximum number of invocations of this command that can be running at the same time.</span>
<span class="sd">    per: :class:`.BucketType`</span>
<span class="sd">        The bucket that this concurrency is based on, e.g. ``BucketType.guild`` would allow</span>
<span class="sd">        it to be used up to ``number`` times per guild.</span>
<span class="sd">    wait: :class:`bool`</span>
<span class="sd">        Whether the command should wait for the queue to be over. If this is set to ``False``</span>
<span class="sd">        then instead of waiting until the command can run again, the command raises</span>
<span class="sd">        :exc:`.MaxConcurrencyReached` to its error handler. If this is set to ``True``</span>
<span class="sd">        then the command waits until it can be executed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">MaxConcurrency</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">per</span><span class="o">=</span><span class="n">per</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="n">wait</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">Command</span><span class="p">):</span>
            <span class="n">func</span><span class="o">.</span><span class="n">_max_concurrency</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">func</span><span class="o">.</span><span class="n">__commands_max_concurrency__</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">decorator</span>

<span class="k">def</span> <span class="nf">before_invoke</span><span class="p">(</span><span class="n">coro</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A decorator that registers a coroutine as a pre-invoke hook.</span>

<span class="sd">    This allows you to refer to one before invoke hook for several commands that</span>
<span class="sd">    do not have to be within the same cog.</span>

<span class="sd">    .. versionadded:: 1.4</span>

<span class="sd">    Example</span>
<span class="sd">    ---------</span>

<span class="sd">    .. code-block:: python3</span>

<span class="sd">        async def record_usage(ctx):</span>
<span class="sd">            print(ctx.author, &#39;used&#39;, ctx.command, &#39;at&#39;, ctx.message.created_at)</span>

<span class="sd">        @bot.command()</span>
<span class="sd">        @commands.before_invoke(record_usage)</span>
<span class="sd">        async def who(ctx): # Output: &lt;User&gt; used who at &lt;Time&gt;</span>
<span class="sd">            await ctx.send(&#39;i am a bot&#39;)</span>

<span class="sd">        class What(commands.Cog):</span>

<span class="sd">            @commands.before_invoke(record_usage)</span>
<span class="sd">            @commands.command()</span>
<span class="sd">            async def when(self, ctx): # Output: &lt;User&gt; used when at &lt;Time&gt;</span>
<span class="sd">                await ctx.send(&#39;and i have existed since {}&#39;.format(ctx.bot.user.created_at))</span>

<span class="sd">            @commands.command()</span>
<span class="sd">            async def where(self, ctx): # Output: &lt;Nothing&gt;</span>
<span class="sd">                await ctx.send(&#39;on Discord&#39;)</span>

<span class="sd">            @commands.command()</span>
<span class="sd">            async def why(self, ctx): # Output: &lt;Nothing&gt;</span>
<span class="sd">                await ctx.send(&#39;because someone made me&#39;)</span>

<span class="sd">        bot.add_cog(What())</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">Command</span><span class="p">):</span>
            <span class="n">func</span><span class="o">.</span><span class="n">before_invoke</span><span class="p">(</span><span class="n">coro</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">func</span><span class="o">.</span><span class="n">__before_invoke__</span> <span class="o">=</span> <span class="n">coro</span>
        <span class="k">return</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">decorator</span>

<span class="k">def</span> <span class="nf">after_invoke</span><span class="p">(</span><span class="n">coro</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A decorator that registers a coroutine as a post-invoke hook.</span>

<span class="sd">    This allows you to refer to one after invoke hook for several commands that</span>
<span class="sd">    do not have to be within the same cog.</span>

<span class="sd">    .. versionadded:: 1.4</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">Command</span><span class="p">):</span>
            <span class="n">func</span><span class="o">.</span><span class="n">after_invoke</span><span class="p">(</span><span class="n">coro</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">func</span><span class="o">.</span><span class="n">__after_invoke__</span> <span class="o">=</span> <span class="n">coro</span>
        <span class="k">return</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">decorator</span>
</pre></div>

	    </div>
            <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, Programming Club.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/jucacrispim/sphinx_pdj_theme">theme</a> provided by <a href="http://poraodojuca.net">Por√£o do Juca</a>.

</footer>
	</div>
	</div>
	  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../../',
            VERSION:'0.0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js">

    </script>
    <script type="text/javascript" src="../../../../_static/underscore.js">

    </script>
    <script type="text/javascript" src="../../../../_static/doctools.js">

    </script>

  

   <script type="text/javascript"
           src="../../../../_static/js/theme.js"></script>

   <script type="text/javascript"
           src="../../../../_static/js/pdj.js"></script>

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

  </body>
</html>